Snap-to-edge implementation checklist
- [ ] Add snap config defaults/fields: enable, threshold_px (24â€“32), preview_border_px, preview_color in config structs; parse in config_load and copy to runtime.
- [ ] Extend client/server model: snap_edge enum; client hot flags/rects (active, preview, restore rect, preview rect/edge); server runtime snap params and preview window XID/mapped state; destroy preview window in server_cleanup.
- [ ] Pure snap math: create snap.h/snap.c with snap_compute_candidate(px, py, workarea, threshold) returning edge + target rect (left/right halves with odd widths handled).
- [ ] Monitor helper: implement monitor_at_point(root_x, root_y) using monitor geom/workarea; fallback to nearest; ensure RandR/workarea caches kept warm.
- [ ] Preview window module: create override-redirect InputOutput window with border width/color from config; expose snap_preview_apply(server, rect*, show) to map/configure/unmap and restack above clients; initialize after wm_become and tear down at cleanup.
- [ ] Drag begin restore: when starting move on snapped client (non-fullscreen/dock/override_redirect), restore desired to snap_restore_frame_rect, clear snap state, mark DIRTY_GEOM; seed interaction_start_* from desired to avoid jump.
- [ ] Drag motion: during INTERACTION_MOVE motion handling, pick monitor via monitor_at_point; compute snap candidate from pointer + workarea + threshold; update client snap_preview fields/edge/rect; flag preview dirty.
- [ ] Drag end: on ButtonRelease (move), if preview active set snap_restore_frame_rect=server, desired=preview rect, mark snap_active/edge and DIRTY_GEOM; always clear preview flags; clear on cancel too.
- [ ] Commit phase: in wm_flush_dirty or equivalent, call snap_preview_apply based on active move client preview; map/configure preview when active, unmap otherwise; keep single flush.
- [ ] Tests: add unit tests for snap_compute_candidate boundaries/odd widths/thresholds and monitor selection helper if feasible.
